# Поиск в ширину (Breadth-first search) позволяет найти кратчайшее расстояние (условно) между двумя объектами, если оно существует.
# Для решения задач необходимо:
                              # смоделировать ее в виде графа;
                              # воспользоваться методом поиска в ширину.
                              
# Граф - это модель связей между объектами и состоит из Узлов и Ребер.

# Метод поиску в ширину использует специальную структуру данных называемой Очередью -> категория данных FIFO (First in, First out - первым вошел, первым вышел.

# Структура данных Очередь поддерживает всего две операции: постановка в Очередь и извлечение из Очереди.

# Реализация (на Python) Графов осуществляется с помощью Хеш - таблиц.

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []             -|
graph["peggy"] = []             |  Данные графы являются направленными, так как пути ведут только к ним, а от них нет.
graph["thom"] = []              |
graph["jonny"] = []            _|

# Реализация алгоритма. Для создания двусторонней очереди(дека) используется функция deque

# СПРАВОЧНО: collections.deque(iterable, [maxlen]) - создаёт очередь из итерируемого объекта с максимальной длиной maxlen. 
# Очереди очень похожи на списки, за исключением того, что добавлять и удалять элементы можно либо справа, либо слева.

# СПРАВОЧНО: popleft() - удаляет и возвращает первый элемент очереди.


from collections import deque
search_queue = deque()                        # создание новой очереди
search-queue += graph["you"]                  # все соседи добавляются в конец очереди

while search_deque:                           # пока очередь не пуста
    person = search_queue.popleft()           # из очереди извлекается первый человек
    if person_is_seller(person):              # проверяем, является ли этот человек продавцом манго
        print (person + "is a mango seller!") # это продавец манго
        return True
    else:
        search_queue += grapg[person]         # если не является, то все друзья этого человека добавляются в очередь поиска
return False        # если выполнение дошло до этой строки, значит в очереди нет продавца манго

# Алгоритм работает до тех пор, пока не будет найден продавец манго или очередь не опустеет (продавца просто нет).



# Итоговая версия кода для поиска в ширину, в котором исключены повторы и зацикливания поиска на повторяемых объектах

def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []                   # массив, используемый для отслеживания уже проверенных объектов
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:             # человек проверяется только в том случае, если не проверялся ранее
            if person_is_seller(person):
                print (person + "is a mango seller!") # это продавец манго
            return True
            else:
                search_queue += grapg[person]
                searched.append(person)        # объект помечается как проверенный
    return False

search ("you")



